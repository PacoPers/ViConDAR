
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>InputParameters</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-11-12"><meta name="DC.source" content="InputParameters.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Header</a></li><li><a href="#2">Input variables for naming and indexing and WF properties</a></li><li><a href="#3">Flags for the different functionalities of the framework. TODO is there a smarter way to avoid all these?</a></li><li><a href="#4">Lidar parameters</a></li><li><a href="#5">Processing lidar measurements</a></li><li><a href="#6">Directory/path definition</a></li><li><a href="#7">Wind turbine parameters</a></li><li><a href="#8">Constrained turbulence codes</a></li><li><a href="#9">Plotting options</a></li></ul></div><h2>Header<a name="1"></a></h2><p>Configuration file for all functionalities of ViConDAR. All the inputs to the virtual lidar and other modules are read from herelidar and other modules are read from here.</p><p>V.Pettas/F.Costa University of Stuttgart, Stuttgart Wind Energy (SWE) 2019</p><pre class="codeinput"><span class="keyword">function</span> input = InputParameters()
</pre><h2>Input variables for naming and indexing and WF properties<a name="2"></a></h2><pre class="codeinput">input.nameBase = <span class="string">'DTU10MW'</span>;
<span class="comment">%free naming conventions by the user. They should appear in the name of the original windfield!</span>
input.freeInp = {   <span class="string">'Sh'</span> ,[5 ];
                    <span class="string">'SD'</span> ,[1];
                    <span class="string">'V'</span>  ,[8 14];
                    <span class="string">'TI'</span> ,[10];
                }; <span class="comment">%#ok&lt;*NBRAK&gt;</span>

<span class="comment">% parameters of the simulator cannot be changed</span>
input.fixedInp={
                <span class="string">'Pat'</span> ;   <span class="comment">%input.PatternNames</span>
<span class="comment">%                 'Ns';     %input.noise_U</span>
                <span class="string">'Tp'</span>;     <span class="comment">%timeStep_pattern</span>
                <span class="string">'Tm'</span>   ;  <span class="comment">%input.timeStep_Measurements</span>
<span class="comment">%                 'Pos'   ; %input.Pos_LiDAR</span>
<span class="comment">%                 'Fd'   ;  %input.ref_plane_dist</span>
<span class="comment">%                 'DAv'  ;  %input.distance_av_space</span>
<span class="comment">%                 'SlAv'  ; %points_av_slice</span>
                };
input.AllFixed = {<span class="string">'Pat'</span>;<span class="string">'Ns'</span>;<span class="string">'Tp'</span>;<span class="string">'Tm'</span>;<span class="string">'Pos'</span>;<span class="string">'Fd'</span> ;<span class="string">'DAv'</span>;<span class="string">'SlAv'</span>}; <span class="comment">% This should not be changed. Only when a new lidar feature is added. This is a list of all the parameters requires to run lidar simulator</span>

<span class="comment">%-------------------------------------------------------------------------%</span>
</pre><h2>Flags for the different functionalities of the framework. TODO is there a smarter way to avoid all these?<a name="3"></a></h2><pre class="codeinput"><span class="comment">%Wrapper global flags to choose the functionality</span>
input.flag_getLidarOutput         = 0; <span class="comment">% Obtain data for comparison between original and lidar measured WF</span>
input.flag_getTurbsimInput        = 1; <span class="comment">% Obtain inputs to create constrained windfield with turbsim</span>
input.flag_getPyconturbInput      = 0; <span class="comment">% Obtain inputs to create constrained windfield with pyconturb</span>
input.flag_obtain_Con_Turbsim     = 0; <span class="comment">% Run turbsim and obtain constrained wind field</span>
input.flag_obtain_Con_Pyconturb_Matlab   = 0; <span class="comment">% Run pyconturb and obtain constrained wind field through matlab</span>
input.flag_obtain_Con_Pyconturb_python   =0; <span class="comment">% Run pyconturb and obtain constrained wind field through the Python wrapper</span>
input.flag_obtain_Con_Pyconturb_ConverToMat = 0; <span class="comment">% After simulation is done with python run this to obtain the windfiels in matlab for further processing with ViConDAR</span>
input.flag_calculate_fullWF_statistics = 0; <span class="comment">% Calculate Vmean,Shear,REWS,TI etc. from the full wind fields (constrained and original). Code looks in all folders using the names provided as input</span>

<span class="comment">%Flags for virtual lidar measurements parameters</span>
input.flag_apply_noise          = 1; <span class="comment">% Apply noise to measured points       ===&gt;  0=NO, 1=YES</span>
input.flag_apply_LOS            = 1; <span class="comment">% Apply Line of sight of LiDAR         ===&gt;  0=NO, 1=YES</span>
input.flag_apply_weightREWS     = 0; <span class="comment">% Weight for the length of the blade for REWS caclulation  ===&gt;  0=NO, 1=YES</span>
input.flag_resampling           = 0; <span class="comment">% apply resampling to the lidar measurments. Current in frequency domain</span>

<span class="comment">% Flags for plotting options</span>
input.flag_plot_lidar          = 0; <span class="comment">% plot lidar measurements vs original windfield</span>
input.flag_plot_WF_timeseries  = 0; <span class="comment">% plot points from the grids of windfields the code will look for all constrained and original windfields with the same name and plot if they exist</span>
input.plot_fullWF_Slices       = 0; <span class="comment">% plot slices in time from the grids of windfields the code will look for all constrained and original windfields with the same name and plot if they exist</span>
<span class="comment">%-------------------------------------------------------------------------%</span>
</pre><h2>Lidar parameters<a name="4"></a></h2><pre class="codeinput">input.PatternY = {[ 54  54 0 -54 -54]; [0 -76.5 76.5 -45 45 -45 45]};    <span class="comment">% Pattern points Y axis (in meters)</span>
input.PatternZ = {[-54  54 0 -54  54];[0 0 0 63 63 -63 -63]}; <span class="comment">% Pattern points Z axis (in meters)</span>

input.PatternNames = {<span class="string">'5P_Squared'</span> <span class="string">'7P_Circular'</span> };  <span class="comment">% names of the patterns. Important: number of names should equal number of Y,Z coordinates</span>
input.timestep_pat_vec      = {[6.5 ] [7]}; <span class="comment">%Time step of the total pattern. Sampling rate of total pattern should be that npoins*timestep_meas&lt;=timestep_pat(s). Add one value for each pattern</span>

input.timeStep_Measurements = {[1.3] }; <span class="comment">%Time step between each single measured point. Add one value for each pattern [s]</span>

input.ref_plane_dist = [250];   <span class="comment">% Reference Plane for LOS (distance[m])</span>
input.Pos_LiDAR      = [0,0]; <span class="comment">% LiDAR position offsetfrom hub center(meters)==&gt; [Y,Z] WE NEED TO FIX THE APPLICATION OF OFFSET IN LOS ONLY!!!! It cannot be used to loop over it. It has to be fixed for now</span>
input.distance_av_space = [30];    <span class="comment">% [m] values to use for imitating range gate averaging in the calcualtion of wind speeds from pulses meters ahead and afer the point</span>
input.points_av_slice   = [5];     <span class="comment">% how many point/slices you want to take in the averaging of distance_av_slice  Totalpoints = distance_av_slice/points_av_slice+1 IT HAS TO BE AN EXACT DIVISION FOR NOW!!!!</span>
input.noise_U  = [20]; <span class="comment">% magnitude of noise to be applied in U time series (see help of awgn function)</span>

input.noise_V  = input.noise_U; <span class="comment">% magnitude of noise to be applied in V time series (see help of awgn function)</span>
input.noise_W  = input.noise_U; <span class="comment">% magnitude of noise to be applied in W time series (see help of awgn function)</span>

<span class="comment">%-------------------------------------------------------------------------%</span>
</pre><h2>Processing lidar measurements<a name="5"></a></h2><pre class="codeinput">input.dist_REWS_nd = [0 0.1 0.50 0.6 0.7 0.85 0.9 0.95 1 ]; <span class="comment">% Non dimentional span position for rotor effective wind speed calculation [define from 0 to 1 inclusive]</span>
input.Wi           = [0.2 0.23 0.4 0.6 0.85 0.95 1 0.6 0 ];  <span class="comment">%Weight to be applied for rotor effective wind speed calculation</span>
input.resampling_factor = 1; <span class="comment">% Amount of desired resampling for outputs in Turbsim and PyConTurb used with flag_resampling</span>

input.nComp                  = 3;        <span class="comment">%1:u, 2:v+u 3:u+v+w % Number of components to process (U,V,W):</span>
input.type_interpolation     = <span class="string">'linear'</span>; <span class="comment">% (interp1) interpolation between slices line460 (check other options of interpm)</span>
input.type_interpolation_2   = <span class="string">'linear'</span>; <span class="comment">% (interp2)  interpolation in selected slice for values on the pattern points</span>
</pre><h2>Directory/path definition<a name="6"></a></h2><p>All directories are strings to be concatenated and they should always finish with \. If you run on Mac/Linux definitions should be change the accordingly</p><pre class="codeinput">input.OriginalWF_dir = <span class="string">'..\OriginalWF\'</span>;      <span class="comment">% Direcotry where original windfileds in .mat format are saved</span>
input.LidarOutput_dir =<span class="string">'..\LidarOutput\'</span>;     <span class="comment">% Directory to save the lidar measurement outputs</span>
input.ConstrainedWF_dir =<span class="string">'..\ConstrainedWF\'</span>; <span class="comment">% Directory to save all constrained windfileds</span>

input.TurbSimInput_dir   = <span class="string">'..\InputsForConstrainedTurb\TurbsimInput\'</span>;   <span class="comment">%Directory to save inputs to use with turbsim constraining functionality</span>
input.PyconturbInput_dir = <span class="string">'..\InputsForConstrainedTurb\PyconturbInput\'</span>; <span class="comment">% Directory to save the required inputs to run Pyconturb for constraining a windfield</span>

input.PyconturbOut_dir = <span class="string">'..\ConstrainedWF\PyConTurb\'</span>; <span class="comment">% Sub directory to save Pyconturb outputs (.mat, .csv)</span>
input.TurbSimOut_dir   = <span class="string">'..\ConstrainedWF\Turbsim\'</span>;  <span class="comment">% Sub directory to save Turbsim outputs (.mat,.wnd etc.)</span>

input.fullWF_statistics_dir = [input.ConstrainedWF_dir <span class="string">'Statistics\'</span>]; <span class="comment">% Directory to store the statistics from full windfields invcluding both original and constrained</span>

input.TurbSimExe_path= <span class="string">'..\ConstrainedWF\Turbsim\TurbSim_x64.exe'</span>; <span class="comment">%Full path to the executable of Turbsim. If other platform than windows is used the correct executable is neeeded</span>

input.pathToTurbSim  = <span class="string">'..\ConstrainedWF\Turbsim\'</span>;  <span class="comment">%</span>
input.TurbSimInpTemplate = <span class="string">'..\ConstrainedWF\Turbsim\Template_Turbsim.inp'</span>; <span class="comment">% Full path to Turbsim tempalte .inp. It is required to build upon it the case specific input.</span>
input.PythonExe_path      = <span class="string">'python'</span>;         <span class="comment">% Path to run python. If python is set as environmental variable writing python is enough. If not, the full path to the correct python environment and executable is required</span>

input.AddUserDir={input.LidarOutput_dir input.ConstrainedWF_dir input.TurbSimInput_dir input.PyconturbInput_dir input.PyconturbOut_dir input.TurbSimOut_dir input.fullWF_statistics_dir};


<span class="comment">%-------------------------------------------------------------------------%</span>
</pre><h2>Wind turbine parameters<a name="7"></a></h2><pre class="codeinput">input.rotor_radius = 89.15; <span class="comment">% Radius of the Rotor [m]</span>
input.Zh           = 119;  <span class="comment">% Hub Height [m]</span>

<span class="comment">%-------------------------------------------------------------------------%</span>
</pre><h2>Constrained turbulence codes<a name="8"></a></h2><pre class="codeinput"><span class="comment">% %Turbsim .inp file options for details see tha manual of Turbsim V2.00 Alpha</span>
input.RandSeed    = round(rand(1)*80682); <span class="comment">% random seed for phases</span>
input.UsableTime  = <span class="string">'"ALL"'</span>;             <span class="comment">% UsableTime input it can also use a number</span>
input.IECstandard = <span class="string">'"1-ED3"'</span>;      <span class="comment">% iec standard edition</span>
input.SCMod1      = <span class="string">'"GENERAL"'</span>;        <span class="comment">% standard coherence model NONE IEC=~GENERAL</span>
input.WindProfileType = <span class="string">'"PL"'</span>; <span class="comment">% "LOG", "PL" and, if we have more than one measuring point we can also use "TS"</span>


<span class="comment">%PyConTurb for details see pycptrub documentation https://rink.pages.windenergy.dtu.dk/pyconturb/index.html</span>
input.flag_save_pyconturb_input   = 0; <span class="comment">% obtain PyConTurb input</span>
input.flag_runPyConTurb           = 0; <span class="comment">% Run pyconturb</span>
input.CondaEnv                    = <span class="string">'PyConEnv'</span>;

<span class="comment">% input options to run pyconturb (passed through the .csv to the python code)</span>
input.turb_class = <span class="string">'B'</span>;
input.coh_model  = <span class="string">'iec'</span>; <span class="comment">% coh_model (str, optional) &#8211; Spatial coherence model specifier. Default is IEC 61400-1.</span>
input.wsp_func   = <span class="string">'power_profile'</span>;<span class="comment">% wsp_func (function, optional): constant_profile or power_profile</span>
input.sig_func   = <span class="string">'iec_sig'</span>; <span class="comment">%sig_func (function, optional):</span>
input.spec_func  = <span class="string">'kaimal_spectrum'</span>;<span class="comment">%spec_func (function, optional). 'kaimal_spectrum',:</span>
input.seed       = uint32(rand(1)*80682); <span class="comment">%seed (int, optional): Optional random seed for turbulence generation. Use the same seed and settings to regenerate the same turbulence box.</span>
input.nf_chunk   = 50000; <span class="comment">%mem_gb (float, optional) &#8211; Size of memory to use when doing the calculations. Increase this number to have faster turbulence generation, but if the number becomes too large the generation will fail.</span>
input.interp_data = <span class="string">'Take_list'</span>; <span class="comment">% Could be 'all','none' or 'Take_list'. If 'Takes_list' then takes into account what we introduce in wsp_func, sig_func and spec_func.</span>
</pre><h2>Plotting options<a name="9"></a></h2><pre class="codeinput">input.points_plot_WF_timeseries = [ 54  54 0; -54  54 0]; <span class="comment">% point in meters on the grid to plot --&gt;[Y;Z] y=-Ymax:dy:Ymax, z=-Zmax:dz:Zmax</span>
input.plot_WF_timeseries_Pyconturb = 1 ; <span class="comment">% use constrained windfields with pyconturb for timeseries</span>
input.plot_WF_timeseries_Turbsim = 1 ; <span class="comment">% use constrained windfields with Turbsim for timeseries</span>

input.time_fullWF_Slices = [ 500 1500]; <span class="comment">% slices in time [s]</span>
input.plot_WF_slices_Pyconturb = 1 ; <span class="comment">% use constrained windfields with pyconturb for plotting slices</span>
input.plot_WF_slices_Turbsim = 0 ; <span class="comment">% use constrained windfields with turbsim for plotting slices</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Header
%
% Configuration file for all functionalities of ViConDAR. All the inputs to 
% the virtual lidar and other modules are read from herelidar and other
% modules are read from here.
%
% V.Pettas/F.Costa
% University of Stuttgart, Stuttgart Wind Energy (SWE) 2019

function input = InputParameters()

%% Input variables for naming and indexing and WF properties

input.nameBase = 'DTU10MW';
%free naming conventions by the user. They should appear in the name of the original windfield!
input.freeInp = {   'Sh' ,[5 ];
                    'SD' ,[1];
                    'V'  ,[8 14];
                    'TI' ,[10];
                }; %#ok<*NBRAK>
            
% parameters of the simulator cannot be changed
input.fixedInp={
                'Pat' ;   %input.PatternNames
%                 'Ns';     %input.noise_U
                'Tp';     %timeStep_pattern
                'Tm'   ;  %input.timeStep_Measurements
%                 'Pos'   ; %input.Pos_LiDAR
%                 'Fd'   ;  %input.ref_plane_dist
%                 'DAv'  ;  %input.distance_av_space
%                 'SlAv'  ; %points_av_slice
                };
input.AllFixed = {'Pat';'Ns';'Tp';'Tm';'Pos';'Fd' ;'DAv';'SlAv'}; % This should not be changed. Only when a new lidar feature is added. This is a list of all the parameters requires to run lidar simulator

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%

%% Flags for the different functionalities of the framework. TODO is there a smarter way to avoid all these?

%Wrapper global flags to choose the functionality
input.flag_getLidarOutput         = 0; % Obtain data for comparison between original and lidar measured WF
input.flag_getTurbsimInput        = 1; % Obtain inputs to create constrained windfield with turbsim
input.flag_getPyconturbInput      = 0; % Obtain inputs to create constrained windfield with pyconturb
input.flag_obtain_Con_Turbsim     = 0; % Run turbsim and obtain constrained wind field
input.flag_obtain_Con_Pyconturb_Matlab   = 0; % Run pyconturb and obtain constrained wind field through matlab
input.flag_obtain_Con_Pyconturb_python   =0; % Run pyconturb and obtain constrained wind field through the Python wrapper
input.flag_obtain_Con_Pyconturb_ConverToMat = 0; % After simulation is done with python run this to obtain the windfiels in matlab for further processing with ViConDAR
input.flag_calculate_fullWF_statistics = 0; % Calculate Vmean,Shear,REWS,TI etc. from the full wind fields (constrained and original). Code looks in all folders using the names provided as input

%Flags for virtual lidar measurements parameters
input.flag_apply_noise          = 1; % Apply noise to measured points       ===>  0=NO, 1=YES
input.flag_apply_LOS            = 1; % Apply Line of sight of LiDAR         ===>  0=NO, 1=YES
input.flag_apply_weightREWS     = 0; % Weight for the length of the blade for REWS caclulation  ===>  0=NO, 1=YES
input.flag_resampling           = 0; % apply resampling to the lidar measurments. Current in frequency domain

% Flags for plotting options
input.flag_plot_lidar          = 0; % plot lidar measurements vs original windfield
input.flag_plot_WF_timeseries  = 0; % plot points from the grids of windfields the code will look for all constrained and original windfields with the same name and plot if they exist
input.plot_fullWF_Slices       = 0; % plot slices in time from the grids of windfields the code will look for all constrained and original windfields with the same name and plot if they exist
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%

%% Lidar parameters

input.PatternY = {[ 54  54 0 -54 -54]; [0 -76.5 76.5 -45 45 -45 45]};    % Pattern points Y axis (in meters)
input.PatternZ = {[-54  54 0 -54  54];[0 0 0 63 63 -63 -63]}; % Pattern points Z axis (in meters)

input.PatternNames = {'5P_Squared' '7P_Circular' };  % names of the patterns. Important: number of names should equal number of Y,Z coordinates
input.timestep_pat_vec      = {[6.5 ] [7]}; %Time step of the total pattern. Sampling rate of total pattern should be that npoins*timestep_meas<=timestep_pat(s). Add one value for each pattern

input.timeStep_Measurements = {[1.3] }; %Time step between each single measured point. Add one value for each pattern [s]

input.ref_plane_dist = [250];   % Reference Plane for LOS (distance[m])
input.Pos_LiDAR      = [0,0]; % LiDAR position offsetfrom hub center(meters)==> [Y,Z] WE NEED TO FIX THE APPLICATION OF OFFSET IN LOS ONLY!!!! It cannot be used to loop over it. It has to be fixed for now
input.distance_av_space = [30];    % [m] values to use for imitating range gate averaging in the calcualtion of wind speeds from pulses meters ahead and afer the point
input.points_av_slice   = [5];     % how many point/slices you want to take in the averaging of distance_av_slice  Totalpoints = distance_av_slice/points_av_slice+1 IT HAS TO BE AN EXACT DIVISION FOR NOW!!!!
input.noise_U  = [20]; % magnitude of noise to be applied in U time series (see help of awgn function)

input.noise_V  = input.noise_U; % magnitude of noise to be applied in V time series (see help of awgn function)
input.noise_W  = input.noise_U; % magnitude of noise to be applied in W time series (see help of awgn function)

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%

%% Processing lidar measurements

input.dist_REWS_nd = [0 0.1 0.50 0.6 0.7 0.85 0.9 0.95 1 ]; % Non dimentional span position for rotor effective wind speed calculation [define from 0 to 1 inclusive]
input.Wi           = [0.2 0.23 0.4 0.6 0.85 0.95 1 0.6 0 ];  %Weight to be applied for rotor effective wind speed calculation
input.resampling_factor = 1; % Amount of desired resampling for outputs in Turbsim and PyConTurb used with flag_resampling

input.nComp                  = 3;        %1:u, 2:v+u 3:u+v+w % Number of components to process (U,V,W):
input.type_interpolation     = 'linear'; % (interp1) interpolation between slices line460 (check other options of interpm)
input.type_interpolation_2   = 'linear'; % (interp2)  interpolation in selected slice for values on the pattern points

%% Directory/path definition
%
% All directories are strings to be concatenated and they should always finish
% with \. If you run on Mac/Linux definitions should be change the accordingly

input.OriginalWF_dir = '..\OriginalWF\';      % Direcotry where original windfileds in .mat format are saved
input.LidarOutput_dir ='..\LidarOutput\';     % Directory to save the lidar measurement outputs
input.ConstrainedWF_dir ='..\ConstrainedWF\'; % Directory to save all constrained windfileds

input.TurbSimInput_dir   = '..\InputsForConstrainedTurb\TurbsimInput\';   %Directory to save inputs to use with turbsim constraining functionality
input.PyconturbInput_dir = '..\InputsForConstrainedTurb\PyconturbInput\'; % Directory to save the required inputs to run Pyconturb for constraining a windfield

input.PyconturbOut_dir = '..\ConstrainedWF\PyConTurb\'; % Sub directory to save Pyconturb outputs (.mat, .csv)
input.TurbSimOut_dir   = '..\ConstrainedWF\Turbsim\';  % Sub directory to save Turbsim outputs (.mat,.wnd etc.)

input.fullWF_statistics_dir = [input.ConstrainedWF_dir 'Statistics\']; % Directory to store the statistics from full windfields invcluding both original and constrained

input.TurbSimExe_path= '..\ConstrainedWF\Turbsim\TurbSim_x64.exe'; %Full path to the executable of Turbsim. If other platform than windows is used the correct executable is neeeded

input.pathToTurbSim  = '..\ConstrainedWF\Turbsim\';  %
input.TurbSimInpTemplate = '..\ConstrainedWF\Turbsim\Template_Turbsim.inp'; % Full path to Turbsim tempalte .inp. It is required to build upon it the case specific input.
input.PythonExe_path      = 'python';         % Path to run python. If python is set as environmental variable writing python is enough. If not, the full path to the correct python environment and executable is required

input.AddUserDir={input.LidarOutput_dir input.ConstrainedWF_dir input.TurbSimInput_dir input.PyconturbInput_dir input.PyconturbOut_dir input.TurbSimOut_dir input.fullWF_statistics_dir};


%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%

%% Wind turbine parameters

input.rotor_radius = 89.15; % Radius of the Rotor [m]
input.Zh           = 119;  % Hub Height [m]

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%

%% Constrained turbulence codes

% %Turbsim .inp file options for details see tha manual of Turbsim V2.00 Alpha
input.RandSeed    = round(rand(1)*80682); % random seed for phases
input.UsableTime  = '"ALL"';             % UsableTime input it can also use a number
input.IECstandard = '"1-ED3"';      % iec standard edition
input.SCMod1      = '"GENERAL"';        % standard coherence model NONE IEC=~GENERAL
input.WindProfileType = '"PL"'; % "LOG", "PL" and, if we have more than one measuring point we can also use "TS"


%PyConTurb for details see pycptrub documentation https://rink.pages.windenergy.dtu.dk/pyconturb/index.html
input.flag_save_pyconturb_input   = 0; % obtain PyConTurb input
input.flag_runPyConTurb           = 0; % Run pyconturb
input.CondaEnv                    = 'PyConEnv';

% input options to run pyconturb (passed through the .csv to the python code)
input.turb_class = 'B';
input.coh_model  = 'iec'; % coh_model (str, optional) – Spatial coherence model specifier. Default is IEC 61400-1.
input.wsp_func   = 'power_profile';% wsp_func (function, optional): constant_profile or power_profile
input.sig_func   = 'iec_sig'; %sig_func (function, optional):
input.spec_func  = 'kaimal_spectrum';%spec_func (function, optional). 'kaimal_spectrum',:
input.seed       = uint32(rand(1)*80682); %seed (int, optional): Optional random seed for turbulence generation. Use the same seed and settings to regenerate the same turbulence box.
input.nf_chunk   = 50000; %mem_gb (float, optional) – Size of memory to use when doing the calculations. Increase this number to have faster turbulence generation, but if the number becomes too large the generation will fail.
input.interp_data = 'Take_list'; % Could be 'all','none' or 'Take_list'. If 'Takes_list' then takes into account what we introduce in wsp_func, sig_func and spec_func.

%% Plotting options

input.points_plot_WF_timeseries = [ 54  54 0; -54  54 0]; % point in meters on the grid to plot REPLACE_WITH_DASH_DASH>[Y;Z] y=-Ymax:dy:Ymax, z=-Zmax:dz:Zmax
input.plot_WF_timeseries_Pyconturb = 1 ; % use constrained windfields with pyconturb for timeseries
input.plot_WF_timeseries_Turbsim = 1 ; % use constrained windfields with Turbsim for timeseries

input.time_fullWF_Slices = [ 500 1500]; % slices in time [s]
input.plot_WF_slices_Pyconturb = 1 ; % use constrained windfields with pyconturb for plotting slices
input.plot_WF_slices_Turbsim = 0 ; % use constrained windfields with turbsim for plotting slices


##### SOURCE END #####
--></body></html>